### 半包
客户端发送数据时，实际是把数据写入TCP发送缓存里面，如果发送的数据包大小比TCP发送缓存的容量大，那么这个数据包就会被分成多个包，通过socket多次发送到服务端。
而服务端获取数据是从缓存中读取的，如果服务端接收到的数据只是客户端发送整个数据包的一部分，这种就成为半包现象，这个时候服务端反序列会失败
总结：【服务端获取的数据是客户端发送数据的一部分，不完整数据】
### 粘包
客户端发送数据时，，数据包比TCP发送缓存容量小，且TCP缓存可以存放多个数据包，那么客户端和服务端的一次通信就可能传递多个数据包，这个时候服务端从接收缓存就可
能一下读取到多个包，出现粘包现象，这个时候服务端反序列化也会失败
总结：【服务端获取的数据多于客户端发送的数据，不完整数据】

### 半包和粘包出现的原因
TCP是不知道上层业务数据包概念的，它只是**单纯的传递流**，所以需要**上层应用协议**来识别读取是不是一个**完整的数据包**
###
***不管是半包还是粘包，原因就是服务端获取到的不是客户端发送的不多不少的完整数据包***

### 常见解决半包与粘包问题的方案
1. 比较常见的方案是应用层设计协议时，把协议包分为**header**个**body**（比如doubbo协议），header里面记录body长度，当服务器从接收缓冲区读取数据后，
如果发现数据大小小于包中的长度则说明出现了半包，继续等待读取数据，如果发现数据大小大于包长度则看大小是否是包长度的整数倍，如果是则循环读取多个包，否则
就是出现了多个整包+半包，也就是粘包现象
2. 多个包之间用”|”分隔 比如：【数据包a|数据包b|数据包c|数据包d】，此时每个数据包的大小是不固定的，服务端读取到”|“就知道当前包结束了，缺点就是数据包中的
数据不能包含”|“，这个很好理解
3. 数据包定长，就是每个数据包的长度是固定的，这个服务端在读取数据时候可以通过固定长度来识别数据包的分界